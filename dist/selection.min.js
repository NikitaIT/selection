/*! Selectionjs 1.5.0 MIT | https://github.com/Simonwep/selection */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Selection"] = factory();
	else
		root["Selection"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/utils.ts
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function eventListener(method, elements, events, fn, options = {}) {
  const normalizedEvents = normalizeArray(events);
  const normalizedElements = normalizeDomArray(elements);

  for (const element of normalizedElements) {
    for (const event of normalizedEvents) {
      element[method](event, fn, _objectSpread({
        capture: false
      }, options));
    }
  }

  return Array.prototype.slice.call(arguments, 1);
}

function normalizeDomArray(elements) {
  if (elements instanceof HTMLCollection || elements instanceof NodeList) {
    return Array.from(elements);
  }

  return normalizeArray(elements);
}

function normalizeArray(elements) {
  if (!Array.isArray(elements)) {
    return [elements];
  }

  return elements;
}

const on = eventListener.bind(null, 'addEventListener');
const off = eventListener.bind(null, 'removeEventListener');
const unitify = (val, unit = 'px') => typeof val === 'number' ? val + unit : val;
function css(el, attr, val) {
  const style = el && el.style;

  if (style) {
    if (typeof attr === 'object') {
      for (const [key, value] of Object.entries(attr)) {
        style[key] = unitify(value);
      }
    } else if (val && typeof attr === 'string') {
      style[attr] = unitify(val);
    }
  }
}
function intersects(a, b, mode) {
  switch (mode || "touch") {
    case "center":
      {
        const bxc = b.left + b.width / 2;
        const byc = b.top + b.height / 2;
        return bxc >= a.left && bxc <= a.right && byc >= a.top && byc <= a.bottom;
      }

    case "cover":
      {
        return b.left >= a.left && b.top >= a.top && b.right <= a.right && b.bottom <= a.bottom;
      }

    case "touch":
      {
        return a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;
      }

    default:
      {
        throw new Error("Unkown intersection mode: ".concat(mode));
      }
  }
}
function selectAll(selector, doc = document) {
  if (!Array.isArray(selector)) {
    selector = [selector];
  }

  return selector.flatMap(item => {
    if (typeof item === 'string') {
      return Array.from(doc.querySelectorAll(item));
    } else if (item instanceof doc.defaultView.HTMLElement) {
      return item;
    }
  });
}
function eventPath(evt) {
  let path = evt.path || evt.composedPath && evt.composedPath();

  if (path) {
    return path;
  }

  let el = evt.target;

  for (path = [el]; el = el.parentElement;) {
    path.push(el);
  }

  path.push(document, window);
  return path;
}
function removeElement(arr, el) {
  const index = arr.indexOf(el);

  if (~index) {
    arr.splice(index, 1);
  }
}
function simplifyEvent(evt) {
  const tap = evt.touches && evt.touches[0] || evt;
  return {
    tap,
    x: tap.clientX,
    y: tap.clientY,
    target: tap.target
  };
}
// CONCATENATED MODULE: ./src/SelectionFrame.ts

function createSelectionFrame(frame) {
  const area = frame.createElement('div');
  const clippingElement = frame.createElement('div');
  clippingElement.appendChild(area);
  return {
    area,
    clippingElement
  };
}
function applyBasicStylesToTheSelectionFrame(selectionFrame) {
  css(selectionFrame.area, {
    willChange: 'top, left, bottom, right, width, height',
    top: 0,
    left: 0,
    position: 'fixed'
  });
  css(selectionFrame.clippingElement, {
    overflow: 'hidden',
    position: 'fixed',
    transform: 'translate3d(0, 0, 0)',
    pointerEvents: 'none',
    zIndex: '1'
  });
}
// CONCATENATED MODULE: ./src/selection.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TapMode", function() { return TapMode; });
function selection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function selection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { selection_ownKeys(source, true).forEach(function (key) { selection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { selection_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function selection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const {
  abs,
  max,
  min,
  round,
  ceil,
  sign
} = Math;

const preventDefault = e => e.preventDefault();

function getKeepSelectionStore() {
  return {
    _stored: [],
    _selectables: [],
    _selected: [],
    _changed: {
      added: [],
      removed: []
    }
  };
}

function getEvenlistenerStore() {
  return {
    beforestart: [],
    start: [],
    move: [],
    stop: []
  };
}

var TapMode;

(function (TapMode) {
  TapMode["native"] = "native";
  TapMode["touch"] = "touch";
})(TapMode || (TapMode = {}));

function isPoint(startThreshold) {
  return typeof startThreshold === 'object';
}

function Selection(options = {}) {
  const areaStartPoint = {
    _ax1: 0,
    _ay1: 0
  };
  const areaEndPoint = {
    _ax2: 0,
    _ay2: 0
  };

  const that = selection_objectSpread({
    _boundaries: [],
    _targetContainer: undefined,
    _targetBoundary: undefined,
    _singleClick: false,
    selectionFrame: null,
    options: selection_objectSpread({
      class: 'selection-area',
      frame: document,
      mode: "touch",
      tapMode: "native",
      startThreshold: 10,
      singleClick: true,
      disableTouch: false,
      selectables: [],
      scrollSpeedDivider: 10,
      manualScrollSpeed: 750,
      startareas: ['html'],
      boundaries: ['html'],
      selectionAreaContainer: 'body'
    }, options)
  }, getKeepSelectionStore(), {
    _eventListener: getEvenlistenerStore(),
    _areaDomRect: null,
    _scrollAvailable: true,
    _scrollSpeed: {
      x: null,
      y: null
    },

    _init() {
      const {
        frame
      } = that.options;
      that.selectionFrame = createSelectionFrame(frame);
      that.selectionFrame.area.classList.add(that.options.class);
      applyBasicStylesToTheSelectionFrame(that.selectionFrame);
      that.enable();
    },

    _bindStartEvents(type) {
      const {
        frame
      } = that.options;
      const fn = type === 'on' ? on : off;
      fn(frame, 'mousedown', that._onTapStart);

      if (!that.options.disableTouch) {
        fn(frame, 'touchstart', that._onTapStart, {
          passive: false
        });
      }
    },

    _onTapStart(evt) {
      const {
        x,
        y,
        target
      } = simplifyEvent(evt);
      const {
        startareas,
        boundaries,
        frame
      } = that.options;
      const targetBoundingClientRect = target.getBoundingClientRect();
      const startAreas = selectAll(startareas, frame);
      that._boundaries = selectAll(boundaries, frame);
      that._targetContainer = that._boundaries.find(el => intersects(el.getBoundingClientRect(), targetBoundingClientRect));

      function isAreaStartsInOneOfTheStartAreasOrBoundaries() {
        const evtpath = eventPath(evt);
        return !that._targetContainer || !startAreas.find(el => evtpath.includes(el)) || !that._boundaries.find(el => evtpath.includes(el));
      }

      if (isAreaStartsInOneOfTheStartAreasOrBoundaries()) {
        return;
      }

      if (that._emit('beforestart', evt) === false) {
        return;
      }

      areaStartPoint._ax1 = x;
      areaStartPoint._ay1 = y;
      areaEndPoint._ax2 = 0;
      areaEndPoint._ay2 = 0;
      that._singleClick = true;
      that.clearSelection(false);
      on(frame, 'selectstart', preventDefault);
      on(frame, ['touchmove', 'mousemove'], that._delayedTapMove, {
        passive: false
      });
      on(frame, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);
      evt.preventDefault();
    },

    _onSingleTap(evt) {
      const {
        tapMode
      } = that.options;
      const spl = simplifyEvent(evt);
      let target = null;

      if (tapMode === "native") {
        target = spl.target;
      } else if (tapMode === "touch") {
        that.resolveSelectables();
        const {
          x,
          y
        } = spl;
        target = that._selectables.find(v => {
          const {
            right,
            left,
            top,
            bottom
          } = v.getBoundingClientRect();
          return x < right && x > left && y < bottom && y > top;
        });
      } else {
        throw new Error("Unknown tapMode option: ".concat(tapMode));
      }

      if (!target) {
        return false;
      }

      that.resolveSelectables();

      while (!that._selectables.includes(target)) {
        if (!target.parentElement) {
          return;
        }

        target = target.parentElement;
      }

      that._emit('start', evt);

      const stored = that._stored;

      if (evt.shiftKey && stored.length) {
        const reference = stored[stored.length - 1];
        const [preceding, following] = reference.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING ? [target, reference] : [reference, target];
        const rangeItems = [...that._selectables.filter(el => el.compareDocumentPosition(preceding) & Node.DOCUMENT_POSITION_FOLLOWING && el.compareDocumentPosition(following) & Node.DOCUMENT_POSITION_PRECEDING), target];
        that.select(rangeItems);

        that._emit('move', evt);

        that._emit('stop', evt);
      } else {
        if (stored.includes(target)) {
          that.removeFromSelection(target);
        } else {
          that.select(target);
        }

        that._emit('move', evt);

        that._emit('stop', evt);
      }
    },

    _delayedTapMove(evt) {
      function isMoreWhenThreshold() {
        const {
          startThreshold
        } = that.options;
        const {
          x,
          y
        } = simplifyEvent(evt);
        const {
          _ax1,
          _ay1
        } = areaStartPoint;
        return typeof startThreshold === 'number' && abs(x + y - (_ax1 + _ay1)) >= startThreshold || isPoint(startThreshold) && (abs(x - _ax1) >= startThreshold.x || abs(y - _ay1) >= startThreshold.y);
      }

      if (isMoreWhenThreshold()) {
        that.__delayedTapMove(evt);
      }

      evt.preventDefault();
    },

    __delayedTapMove(evt) {
      const {
        frame
      } = that.options;
      off(frame, ['mousemove', 'touchmove'], that._delayedTapMove, {
        passive: false
      });
      on(frame, ['mousemove', 'touchmove'], that._onTapMove, {
        passive: false
      });
      css(that.selectionFrame.area, 'display', 'block');
      selectAll(that.options.selectionAreaContainer, frame)[0].appendChild(that.selectionFrame.clippingElement);
      that.resolveSelectables();
      that._singleClick = false;

      const tb = that._targetBoundary = that._targetContainer.getBoundingClientRect();

      that._scrollAvailable = round(that._targetContainer.scrollHeight) !== round(tb.height) || round(that._targetContainer.scrollWidth) !== round(tb.width);

      if (that._scrollAvailable) {
        on(window, 'wheel', that._manualScroll, {
          passive: false
        });
        that._selectables = that._selectables.filter(s => that._targetContainer.contains(s));
        css(that.selectionFrame.clippingElement, {
          top: tb.top,
          left: tb.left,
          width: tb.width,
          height: tb.height
        });
        css(that.selectionFrame.area, {
          marginTop: -tb.top,
          marginLeft: -tb.left
        });
      } else {
        css(that.selectionFrame.clippingElement, {
          top: 0,
          left: 0,
          width: '100%',
          height: '100%'
        });
        css(that.selectionFrame.area, {
          marginTop: 0,
          marginLeft: 0
        });
      }

      that._onTapMove(evt);

      that._emit('start', evt);
    },

    _onTapMove(evt) {
      const {
        x,
        y
      } = simplifyEvent(evt);
      const {
        scrollSpeedDivider
      } = that.options;
      const scon = that._targetContainer;
      let ss = that._scrollSpeed;
      areaEndPoint._ax2 = x;
      areaEndPoint._ay2 = y;

      if (that._scrollAvailable && (ss.y !== null || ss.x !== null)) {
        requestAnimationFrame(function scroll() {
          ss = that._scrollSpeed;
          const scrollY = ss.y !== null;
          const scrollX = ss.x !== null;

          if (!scrollY && !scrollX) {
            return;
          }

          const {
            scrollTop,
            scrollLeft
          } = scon;

          if (scrollY) {
            scon.scrollTop += ceil(ss.y / scrollSpeedDivider);
            areaStartPoint._ay1 -= scon.scrollTop - scrollTop;
          }

          if (scrollX) {
            scon.scrollLeft += ceil(ss.x / scrollSpeedDivider);
            areaStartPoint._ax1 -= scon.scrollLeft - scrollLeft;
          }

          redraw();
          requestAnimationFrame(scroll);
        });
      } else {
        redraw();
      }

      function redraw() {
        that._redrawArea();

        that._updatedTouchingElements();

        that._emit('move', evt);
      }

      evt.preventDefault();
    },

    _manualScroll(evt) {
      const {
        manualScrollSpeed
      } = that.options;
      that._scrollSpeed.y += sign(evt.deltaY) * manualScrollSpeed;
      that._scrollSpeed.x += sign(evt.deltaX) * manualScrollSpeed;

      that._onTapMove(evt);

      evt.preventDefault();
    },

    _redrawArea() {
      const ss = that._scrollSpeed;
      const {
        scrollTop,
        scrollHeight,
        clientHeight,
        scrollLeft,
        scrollWidth,
        clientWidth
      } = that._targetContainer;
      const brect = that._targetBoundary;
      let x = areaEndPoint._ax2;
      let y = areaEndPoint._ay2;
      [ss.x, x] = scrollSpeedWithNewCoord(x, brect.left, brect.width, scrollWidth, scrollLeft, clientWidth);
      [ss.y, y] = scrollSpeedWithNewCoord(y, brect.top, brect.height, scrollHeight, scrollTop, clientHeight);
      const x3 = min(areaStartPoint._ax1, x);
      const y3 = min(areaStartPoint._ay1, y);
      const x4 = max(areaStartPoint._ax1, x);
      const y4 = max(areaStartPoint._ay1, y);
      const width = x4 - x3;
      const height = y4 - y3;
      Object.assign(that.selectionFrame.area.style, {
        transform: "translate3d(".concat(unitify(x3), ", ").concat(unitify(y3)) + ', 0)',
        width: unitify(width),
        height: unitify(height)
      });
      that._areaDomRect = new DOMRect(x3, y3, width, height);
    },

    _onTapStop(evt, noevent) {
      const {
        frame,
        singleClick
      } = that.options;
      off(frame, ['mousemove', 'touchmove'], that._delayedTapMove);
      off(frame, ['touchmove', 'mousemove'], that._onTapMove);
      off(frame, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);

      if (evt && that._singleClick && singleClick) {
        that._onSingleTap(evt);
      } else if (!that._singleClick && !noevent) {
        that._updatedTouchingElements();

        that._emit('stop', evt);
      }

      that._scrollSpeed = {
        x: null,
        y: null
      };
      off(window, 'wheel', that._manualScroll);
      that.selectionFrame.clippingElement.remove();
      off(frame, 'selectstart', preventDefault);
      css(that.selectionFrame.area, 'display', 'none');
    },

    _updatedTouchingElements() {
      const {
        _selected,
        _selectables,
        options,
        _areaDomRect
      } = that;
      const {
        mode
      } = options;

      function isAreaIntersectsElement(node) {
        return intersects(_areaDomRect, node.getBoundingClientRect(), mode);
      }

      const touched = _selectables.filter(isAreaIntersectsElement);

      const added = touched.filter(node => !_selected.includes(node));

      const removed = _selected.filter(el => !touched.includes(el));

      that._selected = touched;
      that._changed = {
        added,
        removed
      };
    },

    _emit(event, evt) {
      return that._eventListener[event].reduce((ok, listener) => {
        return listener.call(that, {
          inst: that,
          area: that.selectionFrame.area,
          selected: that._selected.concat(that._stored),
          changed: that._changed,
          oe: evt
        }) && ok;
      }, true);
    },

    on(event, cb) {
      that._eventListener[event].push(cb);

      return that;
    },

    off(event, cb) {
      const callBacks = that._eventListener[event];

      if (callBacks) {
        const index = callBacks.indexOf(cb);

        if (~index) {
          callBacks.splice(index, 1);
        }
      }

      return that;
    },

    resolveSelectables() {
      that._selectables = selectAll(that.options.selectables, that.options.frame);
    },

    keepSelection() {
      const {
        _selected,
        _stored
      } = that;

      for (let i = 0; i < _selected.length; i++) {
        const el = _selected[i];

        if (!_stored.includes(el)) {
          _stored.push(el);
        }
      }
    },

    clearSelection(store = true) {
      store && (that._stored = []);
      that._selected = [];
      that._changed.added = [];
      that._changed.removed = [];
    },

    removeFromSelection(el) {
      that._changed.removed.push(el);

      removeElement(that._stored, el);
      removeElement(that._selected, el);
    },

    getSelection() {
      return that._stored;
    },

    cancel(keepEvent = false) {
      that._onTapStop(null, !keepEvent);
    },

    option(name, value) {
      const {
        options
      } = that;
      return value === undefined ? options[name] : options[name] = value;
    },

    disable() {
      that._bindStartEvents('off');
    },

    destroy() {
      that.disable();
      that.selectionFrame.clippingElement.remove();
    },

    enable() {
      that._bindStartEvents('on');
    },

    select(query) {
      const {
        _selected,
        _stored,
        options
      } = that;
      const elements = selectAll(query, options.frame).filter(el => !_selected.includes(el) && !_stored.includes(el));

      that._selected.push(...elements);

      that._changed.added.push(...elements);

      return elements;
    }

  });

  that._init();

  return that;
}

function scrollSpeedWithNewCoord(coord, directionCoord, length, scrollLength, scrollDirectionCoord, clientLength) {
  if (coord < directionCoord) {
    return [scrollDirectionCoord ? -abs(directionCoord - coord) : null, directionCoord];
  } else {
    const alternateDirectionCoord = directionCoord + length;

    if (coord > alternateDirectionCoord) {
      return [scrollLength - scrollDirectionCoord - clientLength ? abs(alternateDirectionCoord - coord) : null, alternateDirectionCoord];
    }
  }

  return [null, coord];
}

Selection.utils = {
  on: on,
  off: off,
  css: css,
  intersects: intersects,
  selectAll: selectAll,
  eventPath: eventPath,
  removeElement: removeElement
};

Selection.create = options => Selection(options);

/* harmony default export */ var selection = __webpack_exports__["default"] = (Selection);

/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=selection.min.js.map